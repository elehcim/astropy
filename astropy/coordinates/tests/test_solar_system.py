from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

from ...time import Time
from ... import units as u
from ...constants import c
from ..builtin_frames import GCRS
from ..earth import EarthLocation
from ..sky_coordinate import SkyCoord
from ..solar_system import get_body, get_moon, _apparent_position_in_true_coordinates
from ...tests.helper import pytest, assert_quantity_allclose, remote_data

try:
    import jplephem  # pylint: disable=W0611
except ImportError:
    HAS_JPLEPHEM = False
else:
    HAS_JPLEPHEM = True

try:
    from skyfield.api import load  # pylint: disable=W0611
except ImportError:
    HAS_SKYFIELD = False
else:
    HAS_SKYFIELD = True

separation_tolerance_planets = 5*u.arcsec
separation_tolerance_moon = 5*u.arcsec
distance_tolerance = 20*u.km

skyfield_angular_separation_tolerance = 1*u.arcsec
skyfield_separation_tolerance = 10*u.km


@remote_data
@pytest.mark.skipif(str('not HAS_SKYFIELD'))
def test_positions_skyfield():
    """
    Test positions against those generated by skyfield.
    """

    t = Time('1980-03-25 00:00')
    location = None

    # skyfield ephemeris
    planets = load('de421.bsp')
    ts = load.timescale()
    mercury, jupiter, moon = planets['mercury'], planets['jupiter barycenter'], planets['moon']
    earth = planets['earth']

    skyfield_t = ts.from_astropy(t)

    if location is not None:
        earth = earth.topos(latitude_degrees=location.latitude.to(u.deg).value,
                            longitude_degrees=location.longitude.to(u.deg).value,
                            elevation_m=location.height.to(u.m).value)

    skyfield_mercury = earth.at(skyfield_t).observe(mercury).apparent()
    skyfield_jupiter = earth.at(skyfield_t).observe(jupiter).apparent()
    skyfield_moon = earth.at(skyfield_t).observe(moon).apparent()

    if location is not None:
        obsgeoloc, obsgeovel = location.get_gcrs_posvel(t)
        frame = GCRS(obstime=t, obsgeoloc=obsgeoloc, obsgeovel=obsgeovel)
    else:
        frame = GCRS(obstime=t)

    ra, dec, dist = skyfield_mercury.radec(epoch='date')
    skyfield_mercury = SkyCoord(ra.to(u.deg), dec.to(u.deg), distance=dist.to(u.km),
                                frame=frame)
    ra, dec, dist = skyfield_jupiter.radec(epoch='date')
    skyfield_jupiter = SkyCoord(ra.to(u.deg), dec.to(u.deg), distance=dist.to(u.km),
                                frame=frame)
    ra, dec, dist = skyfield_moon.radec(epoch='date')
    skyfield_moon = SkyCoord(ra.to(u.deg), dec.to(u.deg), distance=dist.to(u.km),
                             frame=frame)

    moon_astropy = get_moon(t, location)
    mercury_astropy = get_body(t, 'mercury', location)
    jupiter_astropy = get_body(t, 'jupiter', location)

    # convert to true equator and equinox
    jupiter_astropy = _apparent_position_in_true_coordinates(jupiter_astropy)
    mercury_astropy = _apparent_position_in_true_coordinates(mercury_astropy)
    moon_astropy = _apparent_position_in_true_coordinates(moon_astropy)

    assert (moon_astropy.separation(skyfield_moon) <
            skyfield_angular_separation_tolerance)
    assert (moon_astropy.separation_3d(skyfield_moon) < skyfield_separation_tolerance)

    assert (jupiter_astropy.separation(skyfield_jupiter) <
            skyfield_angular_separation_tolerance)
    assert (jupiter_astropy.separation_3d(skyfield_jupiter) <
            skyfield_separation_tolerance)

    assert (mercury_astropy.separation(skyfield_mercury) <
            skyfield_angular_separation_tolerance)
    assert (mercury_astropy.separation_3d(skyfield_mercury) <
            skyfield_separation_tolerance)


@remote_data
@pytest.mark.skipif(str('not HAS_JPLEPHEM'))
def test_positions_distances_geocentric_1980():
    """
    Test positions against those generated by JPL Horizons accessed on
    2016-03-28, with refraction turned on.
    """
    t = Time('1980-03-25 00:00')

    frame = GCRS(obstime=t)

    moon_astropy_1980 = get_moon(t)
    mercury_astropy_1980 = get_body(t, 'mercury')
    jupiter_astropy_1980 = get_body(t, 'jupiter')

    # convert to true equator and equinox
    jupiter_astropy_1980 = _apparent_position_in_true_coordinates(jupiter_astropy_1980)
    mercury_astropy_1980 = _apparent_position_in_true_coordinates(mercury_astropy_1980)
    moon_astropy_1980 = _apparent_position_in_true_coordinates(moon_astropy_1980)

    # Results returned by JPL Horizons web interface
    d_mercury_1980 = c*(6.323037*u.min)
    d_moon_1980 = c*(0.021921*u.min)
    d_jupiter_1980 = c*(37.694557*u.min)
    mercury_horizons_1980 = SkyCoord(ra='22h41m47.78s', dec='-08d29m32.0s',
                                     distance=d_mercury_1980,
                                     frame=frame)
    moon_horizons_1980 = SkyCoord(ra='07h32m02.62s', dec='+18d34m05.0s',
                                  distance=d_moon_1980,
                                  frame=frame)
    jupiter_horizons_1980 = SkyCoord(ra='10h17m12.82s', dec='+12d02m57.0s',
                                     distance=d_jupiter_1980,
                                     frame=frame)

    # Assert sky coordinates are close
    assert (mercury_astropy_1980.separation(mercury_horizons_1980) <
            separation_tolerance_planets)
    assert (jupiter_astropy_1980.separation(jupiter_horizons_1980) <
            separation_tolerance_planets)
    assert (moon_astropy_1980.separation(moon_horizons_1980) <
            separation_tolerance_moon)

    # Assert distances are close
    distances_astropy = [mercury_astropy_1980.distance,
                         moon_astropy_1980.distance,
                         jupiter_astropy_1980.distance]
    distances_horizons = [d_mercury_1980, d_moon_1980, d_jupiter_1980]

    assert_quantity_allclose(distances_astropy, distances_horizons,
                             atol=distance_tolerance)


@remote_data
@pytest.mark.skipif(str('not HAS_JPLEPHEM'))
def test_positions_distances_kittpeak_2016():
    """
    Test positions against those generated by JPL Horizons accessed on
    2016-03-28, with refraction turned on.
    """
    t = Time('2016-09-25 00:00')
    kitt_peak = EarthLocation.from_geodetic(lon=-111.6*u.deg,
                                            lat=31.963333333333342*u.deg,
                                            height=2120*u.m)
    obsgeoloc, obsgeovel = kitt_peak.get_gcrs_posvel(t)
    frame = GCRS(obstime=t, obsgeoloc=obsgeoloc, obsgeovel=obsgeovel)

    moon_astropy_2016 = get_moon(t, kitt_peak)
    mercury_astropy_2016 = get_body(t, 'mercury', kitt_peak)
    jupiter_astropy_2016 = get_body(t, 'jupiter', kitt_peak)

    # convert to true equator and equinox
    jupiter_astropy_2016 = _apparent_position_in_true_coordinates(jupiter_astropy_2016)
    mercury_astropy_2016 = _apparent_position_in_true_coordinates(mercury_astropy_2016)
    moon_astropy_2016 = _apparent_position_in_true_coordinates(moon_astropy_2016)

    # Results returned by JPL Horizons web interface
    d_mercury_2016 = c*(7.063423*u.min)
    d_moon_2016 = c*(0.021353*u.min)
    d_jupiter_2016 = c*(53.675045*u.min)
    mercury_horizons_2016 = SkyCoord(ra='11h06m51.50s', dec='+05d59m21.1s',
                                     distance=d_mercury_2016,
                                     frame=frame)
    moon_horizons_2016 = SkyCoord(ra='07h31m39.92s', dec='+16d54m56.8s',
                                  distance=d_moon_2016,
                                  frame=frame)
    jupiter_horizons_2016 = SkyCoord(ra='12h13m59.47s', dec='-00d19m30.5s',
                                     distance=d_jupiter_2016,
                                     frame=frame)

    # Assert sky coordinates are close
    assert (mercury_astropy_2016.separation(mercury_horizons_2016) <
            separation_tolerance_planets)
    assert (jupiter_astropy_2016.separation(jupiter_horizons_2016) <
            separation_tolerance_planets)
    assert (moon_astropy_2016.separation(moon_horizons_2016) <
            separation_tolerance_moon)

    # Assert distances are close
    distances_astropy = [mercury_astropy_2016.distance,
                         moon_astropy_2016.distance,
                         jupiter_astropy_2016.distance]
    distances_horizons = [d_mercury_2016, d_moon_2016, d_jupiter_2016]

    assert_quantity_allclose(distances_astropy, distances_horizons,
                             atol=distance_tolerance)
